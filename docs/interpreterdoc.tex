% This LaTeX document was generated using the LaTeX backend of PlDoc,
% The SWI-Prolog documentation system



\section{ngames/evaluation/interpreter.pl}

\label{sec:interpreter}

\begin{description}
    \predicate[det]{query}{1}{?Term:term}
Substitute for the usual \predref{call}{1} predicate, but includes support for
terms expressed as conjunctions (e.g. A and B).

\begin{arguments}
\arg{Term} & A Prolog term to be queried. \\
\end{arguments}

    \predicate[det]{query_rule}{1}{?Rule:term}
Return True if \arg{Rule} is active given the current state of the system.

\begin{arguments}
\arg{Rule} & A '\predref{rule}{4}` predicate. \\
\end{arguments}

    \predicate[det]{find_consequences}{4}{+ID:atom, +Type:atom, +Threshold:int, -L:list}
Find the instantitations of the if-then-where rules of the '\arg{Type}` kind
that are currently active, and extract their consequences paired with their
priority. Active rules with priority larger than '\arg{Threshold}` are excluded.

\begin{arguments}
\arg{ID} & Identifier for the action situation. \\
\arg{Type} & One of either 'boundary`, 'position`, 'choice`, 'control` or
'payoff`. \\
\arg{Threshold} & The maximum priority of rules to be considered. \\
\arg{L} & The output list with the processed consequences. \\
\end{arguments}

    \predicate[det]{delete_key_gt}{3}{L:list, N:int, NewL:list}
Auxiliary predicate to delete consequences whose priority is over some
given threshold.

\begin{arguments}
\arg{L} & List with priority-fluents pairs to be processed. \\
\arg{N} & Threshold, fluents with priority over it are to be excluded. \\
\arg{NewL} & List identical to '\arg{L}`, but fluents with priority over Threshold
are excluded. \\
\end{arguments}

    \predicate[det]{process_consequences}{3}{+Conseqs:list, +OldParts:list, ?NewParts:list}
Get all the consequences of some rule type and process them in decreasing
order of priority. It returns a new list indicating the consequences that
hold, negated ones (aka overwritten) included. The list of consequences
is processed in a way such that consequences that are in conflict with
consequences of higher priority are discarded.

It should be called as:

\Sdirective{} \verb$find_consequences(boundary,L)$,\verb$process_consequences(L,[],P)$.

\begin{arguments}
\arg{Conseqs} & List of consequence of some rule type. \\
\arg{OldParts} & List of old consequences. Intended to be called with the
empty list. \\
\arg{NewParts} & List of the consequences that hold, negations included. \\
\end{arguments}

    \predicate[det]{get_simple_consequences}{4}{+ID:str, +Type:str, +Threshold:int, -L:list}
Process the consequences of boundary, position, choice and payoff rules.
It gets the consequences of the rules with the given identification and
type, has rules of higher priority overwrite rules of lower priority, and
finally deletes negated (aka overwritten) facts. It returns the result in
a list of fluents.

\begin{arguments}
\arg{ID} & Identifier of the action situation. \\
\arg{Type} & One of either 'boundary`, 'position`, 'choice` or 'payoff`. \\
\arg{Threshold} & Consequences of rules with priorities exceeding `\arg{Threshold}'
are excluded. \\
\end{arguments}

    \predicate[det]{control_conseq_fact_incompatible}{2}{+Fact:atom, +S:list}
Check whether a single fact is compatible with a list of established facts.

\begin{arguments}
\arg{Fact} & The fluent whose compatibility we want to check. \\
\arg{S} & List of previously established facts. \\
\end{arguments}

    \predicate[det]{control_conseq_incompatible}{2}{+Facts:atom, +S:list}
Checks whether the fluents in '\arg{Facts}` that make up a joint consequence
statement of an active control rule are incompatible with the next states
already derived in '\arg{S}`.

\begin{arguments}
\arg{Facts} & \arg{Facts} derived from a new control rule. Either a single fact
or a conjunction of them (aka 'A and B`). \\
\arg{S} & List of potential next state descriptions already derived
(aka a list of lists). \\
\end{arguments}

    \predicate[det]{control_rule_incompatible}{2}{+Conseqs:list, +S:list}
Check whether the '\arg{Conseqs}` list of an active control rule is compatible
with the next states already derived in '\arg{S}`.

\begin{arguments}
\arg{Conseqs} & List of facts derived from a control rule. Each of them is
either a single fact or a conjunction (aka 'A and B`). \\
\arg{S} & List of potential next state descriptions already derived
(aka a list of lists). \\
\end{arguments}

    \predicate[det]{add_rule_conseqs_to_next_states}{7}{+Conseqs:list, +S:list, +P:list, +OldNextS:list, +OldNextP:list, -NewNextS:list, -NewNextP:list}
Given the potential next states derived in '\arg{S}` and their probabilities
in '\arg{P}`, add the consequences in '\arg{Conseqs}` of an active control rule.

Intended to be called as:

\Sdirective{} \verb$add_rule_conseqs_to_next_states(Conseqs,S,P,[],[],NewS,NewP)$.

\begin{arguments}
\arg{Conseqs} & A list of consequences from an active control rule,
with the format 'Facts withProb \arg{P}`. \\
\arg{S} & List of alredy derived next states. \\
\arg{P} & List of the probabilities of the already derived next states. \\
\arg{OldNextStates} & List of partially processed next states. \\
\arg{OldNextP} & List of partially processed next states' probabilities. \\
\arg{NewNextS} & List of next states after processing all of '\arg{Conseqs}`. \\
\arg{NewNextP} & List of next states' probabilities after processing all
of '\arg{Conseqs}`. \\
\end{arguments}

    \predicate[det]{add_joint_conseqs_to_next_states}{5}{+F:term, +OldNextStates:list, +OldProb:list, -NewNextStates:list, -NewProb:list}
Given a fact (or conjunction of facts) alonside with their probability
('C withProb P`), derived from an activated control rule, update the list of
'\arg{OldNextStates}` and their probabilities '\arg{OldProb}` into '\arg{NewNextStates}`
and '\arg{NewProb}`.

\begin{arguments}
\arg{F} & Consequence derived from an active control rule, joint by
operator 'withProb` to its probability. \\
\arg{OldNextStates} & List of next states prior to update. \\
\arg{OldProb} & List of next states' probabilities prior to update. \\
\arg{NewNextStates} & List of updated next states. \\
\arg{NewProb} & List of updated next states' probabilities. \\
\end{arguments}

    \predicate[det]{add_joint_conseqs_to_single_state}{5}{+F:term, +State:list, +Prob:float, -NewState:list, -NewProb:float}
Takes one consequence fact '\arg{F}` (expressed as 'C withProb P`)
from an activated control rule, a state 'S` to be updated (as a list of
fluents) with probability '\arg{Prob}` and return the updated state fluents
and probability.

\begin{arguments}
\arg{F} & A fact (or conjunction of facts) to append to the partially
derived state 'S`. \\
\arg{State} & List of facts that make up a partially derived state. \\
\arg{Prob} & Intermediate probability of the partially derived state. \\
\arg{NewState} & List of updated state fluents. \\
\arg{NewProb} & Updated probability ('i.e.` product of intermediate state
probability and probability of the derived facts). \\
\end{arguments}

    \predicate[det]{joint_conseqs_to_list}{3}{+Old:list, +F:atom, -New:list}
Auxiliary predicate to append a fact or a conjunction of facts
(aka 'A and B`) to a list of fluent.

\begin{arguments}
\arg{Old} & List where new fluents are to be appended. \\
\arg{F} & Fact or conjunction of facts to be appended. \\
\arg{New} & Updated list of facts. \\
\end{arguments}

    \predicate[det]{drag_compatible_fact}{3}{+PreTranFact:atom, +PostTranState:list, -UpdatedPostTransState:list}
If compatible, update a provisional next state with a fluent from the pre-
transition state.

\begin{arguments}
\arg{PreTranFact} & A fluent that holds true in some pre-transition state. \\
\arg{PostTranState} & Partially constructed post-transition state. \\
\arg{UpdatedPostTransState} & Post transition state updated with '\arg{PreTranFact}`. \\
\end{arguments}

    \predicate[det]{drag_compatible_fact}{3}{+PreTranFact:list, +PostTranState:list, -UpdatedPostTransState:list}
Update a partially constructed post-transition state '\arg{PostTranState}` with
the compatible facts from pre-transition state '\arg{PreTranFact}'

\begin{arguments}
\arg{PreTranFact} & List of pretransition state facts. \\
\arg{PostTranState} & Partially constructed post-transition state, as a list
of facts. \\
\arg{UpdatedPostTransState} & Updated post-transition state. \\
\end{arguments}

    \predicate[det]{update_all_new_states}{3}{+PreTranState:list, +PostTranStates:list, -UpdatedPostTransStates:list}
Update all the potential next states sin '\arg{PostTranStates}` with the compatible
facts in '\arg{PreTranState}`.

\begin{arguments}
\arg{PreTranState} & List of fluents in the pre-transition state. \\
\arg{PostTranStates} & Partially constructed post-transition states
(aka a list of lists). \\
\arg{UpdatedPostTransStates} & Updated post-transition states. \\
\end{arguments}

    \predicate[det]{add_control_rules}{5}{+RuleConseqs:list, +OldNextS:list, +OldNextP:list, -NewNextS:list, -NewNextP:list}
Given the priority-consequences pairs of the activated control rules in
'\arg{RuleConseqs}`, append them to the provisional states in '\arg{OldNextS}`
with their unadapted probabilities in '\arg{OldNextP}`. If the rule is compatible
with the facts already established, add the consequences into '\arg{NewNextS}`
and update the probabilities into '\arg{NewNextP}`.

\begin{arguments}
\arg{RuleConseqs} & List of priority-facts consequences derived from the
activated control rules. \\
\arg{OldNextS} & List of unupdated post-transition states (aka a list of
lists). \\
\arg{OldNextP} & List of unupdated probabilities for the post-transition
states. \\
\arg{NewNextS} & List of updated post-transition states (aka a list of lists). \\
\arg{NewNextP} & List of updated post-transition states probabilities. \\
\end{arguments}

    \predicate[det]{get_control_consequences}{5}{+ID:str, +Threshold:int, +PreTranState:list, -PostTranState:list, -Probs:list}
Gather the consequences of control rules given the current state for the
action situation of interest. The rules whose priority exceeds '\arg{Threshold}`
are excluded.

\begin{arguments}
\arg{ID} & Identifier of the action situation. \\
\arg{Threshold} & Rules whose priority exceed it are excluded from processing. \\
\arg{PreTranState} & List of pre-transition state facts. \\
\arg{PostTranState} & List of possible post-transition states
(aka a list of lists). \\
\arg{Probs} & List of probabilities of the post-transition states. \\
\end{arguments}
\end{description}

